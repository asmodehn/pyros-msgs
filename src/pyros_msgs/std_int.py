from __future__ import absolute_import
from __future__ import print_function

"""
Defining Schema for basic ros types

These are used when converting a Ros Message (as a type generated by genmsg) to dict, string, json, etc. and also python.

From wiki.ros.org/msg :
Primitive Type    | Serialization                     | C++           | Python
------------------------------------------------------------------------------
int8              | signed 8-bit int                  | int8_t        | int
uint8             | unsigned 8-bit int                | uint8_t       | int (3)
int16             | signed 16-bit int                 | int16_t       | int
uint16            | unsigned 16-bit int               | uint16_t      | int
int32             | signed 32-bit int                 | int32_t       | int
uint32            | unsigned 32-bit int               | uint32_t      | int
int64             | signed 64-bit int                 | int64_t       | long
uint64            | unsigned 64-bit int               | uint64_t      | long

uint8 has special meaning in Python.uint8[] is treated as a Python bytes so that it is compatible with other byte-oriented APIs in Python.

Deprecated:
char: deprecated alias for uint8
byte: deprecated alias for int8

Array handling:
Array Type        |   Serialization           |  C + +                                        |  Python
-------------------------------------------------------------------------------------------------------
fixed - length    | no extra serialization    | 0.11 +: boost::array, otherwise: std::vector  | tuple(1)
variable - length | uint32 length prefix      | std::vector                                   | tuple(1)
uint8[]           | see above                 |  as above                                     | bytes(2)

In rospy, arrays are deserialized as tuples for performance reasons, but you can set fields to tuples and lists interchangeably.
rospy treats uint8[] data as a bytes, which is the Python representation for byte data.In Python 2, this is the same as str.


Detailed Ref : http://wiki.ros.org/std_msgs

These Fields and Schema are meant to be used together with ROS message type serialization :
ROSTCP --deserialize in rospy--> std_msgs.msg.[U]Int[8/16/32/64] --serialize (dump) in pyros_msgs--> dict
And reversely :
dict --deserialize (load) in pyros_msgs--> std_msgs.msg.[U]Int[8/16/32/64] --serialize in rospy--> ROSTCP

This helps pyros deal efficiently with data only as dicts without worrying about the underlying rospy implementation.

"""


import marshmallow
import std_msgs.msg as std_msgs

# To be able to run doctest, resolving relative to package problem

from .decorators import with_field_validation, with_schema_validation, with_factorymethod_on_deserialize

# Both pyros and rospy serialization could eventually be combined, to serialize only once and get a dict.
# TODO : investigate
# KISS as much as possible for now

# Abstracting what we can, we have a lot of Ros int types.
# Decorating all of them.


#
# Fields declaration
# Since the rospy message type member field is already a python int,
# we do not need anything special here, we rely on marshmallow python type validation.
# Yet we are specifying each on in case we want to extend it later...
#

RosFieldInt8 = marshmallow.fields.Integer
RosFieldUInt8 = marshmallow.fields.Integer
RosFieldInt16 = marshmallow.fields.Integer
RosFieldUInt16 = marshmallow.fields.Integer
RosFieldInt32 = marshmallow.fields.Integer
RosFieldUInt32 = marshmallow.fields.Integer
RosFieldInt64 = marshmallow.fields.Integer
RosFieldUInt64 = marshmallow.fields.Integer


#
# Schemas declaration
# Since we want to provide seamless but safe rospy message type <-> pyros dict conversion
# We need to validate on serialization (dump to dict)
# and create a rospy message type on deserialization (load from dict)
#

@with_schema_validation(std_msgs.Int8)
@with_factorymethod_on_deserialize(std_msgs.Int8)
class RosMsgInt8(marshmallow.Schema):
    """
    RosMsgInt8 handles serialization from {std_msgs.Int8} to python dict
    and deserialization from python dict to {std_msgs.Int8}

    >>> schema = RosMsgInt8()

    >>> rosmsgFortytwo = std_msgs.Int8(data=42)
    >>> marshalledFortytwo, errors = schema.dump(rosmsgFortytwo)
    >>> marshmallow.pprint(marshalledFortytwo) if not errors else print("ERRORS {{0}}".format(errors))
    {{u'data': 42}}
    >>> value, errors = schema.load(marshalledFortytwo)
    >>> type(value) if not errors else print("ERRORS {{0}}".format(errors))
    <class '{ros_int_type}'>
    >>> print(value) if not errors else print("ERRORS {{0}}".format(errors))
    data: 42

    Invalidate message would report:
    >>> rosmsgFortytwo = std_msgs.UInt16(data=42)
    >>> marshalledFortytwo, errors = schema.dump(rosmsgFortytwo)
    >>> print(errors)

    Note since PEP https://www.python.org/dev/peps/pep-0237/  (python 2.4) int and long should mean the same thing for python

    Load is the inverse of dump (getting only data member):
    >>> import random
    >>> randomRosBool = std_msgs.Bool(random.choice([True, False]))
    >>> schema.load(schema.dump(randomRosBool).data).data == randomRosBool
    True
    """
    data = RosFieldInt8()
    pass




